{"version":3,"sources":["webpack://CanvasUtils/webpack/universalModuleDefinition","webpack://CanvasUtils/webpack/bootstrap","webpack://CanvasUtils/./src/index.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,qCAAqC;AAChD;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,WAAW,uCAAuC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,aAAa;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,2DAA2D;AACtE,SAAS,qBAAqB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,wBAAwB;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB,sBAAsB;AACtB,yBAAyB;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,2EAA2E,EAAE,aAAa;;AAE1F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,sEAAsE,EAAE,aAAa;;AAErF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"canvas-utils.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CanvasUtils\"] = factory();\n\telse\n\t\troot[\"CanvasUtils\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","/**\n * TODO:\n * 1. 文本下划线，波浪下划线\n *\n */\nfunction CanvasUtils(id, component = this) {\n  const ctx = wx.createCanvasContext(id, component)\n  const DEFAULT_TEXT_CONFIG = {\n    fontSize: 16,\n    color: '#000',\n    baseLine: 'top',\n    textAlign: 'left',\n    lineHeight: 16,\n    bold: false,\n    maxWidth: undefined,\n    draw: true /** 是否需要绘制出来，当测量时不需要绘制出来 */,\n    textIndent: 0,\n  }\n\n  let config = {\n    CANVAS_HEIGHT: 1750,\n    CANVAS_WIDTH: 1750,\n    /** 当前的文字配置 */\n    text: Object.assign({}, DEFAULT_TEXT_CONFIG),\n    coordinate: {\n      gear: 50,\n      lineWidth: 1,\n      dashWidth: 1,\n      gapWidth: 5,\n    },\n  }\n\n  /**\n   * 实用函数\n   */\n  const degToRad = function(deg) {\n    return (Math.PI * deg) / 180\n  }\n\n  const getContext = function() {\n    return ctx\n  }\n\n  // 计算矩形的bounding rect\n  const calcBoundingRect = function(rect) {\n    const boundingRect = {\n      top: rect.y,\n      bottom: rect.y + rect.height,\n      left: rect.x,\n      right: rect.x + rect.width,\n    }\n    return Object.assign({}, rect, boundingRect)\n  }\n\n  /**\n   * 参考系统\n   */\n\n  const drawCoordinate = function(options) {\n    Object.assign(config.coordinate, options)\n    const {CANVAS_HEIGHT, CANVAS_WIDTH} = config\n    const {gear, lineWidth, dashWidth, gapWidth} = config.coordinate\n    const times = CANVAS_HEIGHT / gear\n    ctx.setLineWidth(lineWidth)\n    ctx.setLineDash([dashWidth, gapWidth], 0)\n    ctx.setStrokeStyle('#CCC')\n    for (let i = 0; i < times; i++) {\n      ctx.beginPath()\n      ctx.moveTo(0, i * gear)\n      ctx.lineTo(CANVAS_WIDTH, i * gear)\n      ctx.stroke()\n      ctx.moveTo(i * gear, 0)\n      ctx.lineTo(i * gear, CANVAS_HEIGHT)\n      ctx.stroke()\n      ctx.closePath()\n    }\n  }\n\n  /**\n   * 文字处理\n   * 要实现：\n   * 1. 文本换行\n   * 2. 文本加粗\n   */\n\n  // 重新计算对齐方式不同的文本的 rect\n  const _recalcAlignTextRect = function(rect, textAlign) {\n    if (textAlign === 'right') {\n      rect.x -= rect.width\n      return rect\n    } else if (textAlign === 'center') {\n      rect.x -= rect.width / 2\n      return rect\n    } else {\n      return rect\n    }\n  }\n\n  // 画文字\n  const _drawText = function(text = '', x = 0, y = 0, draw = true, textIndent = 0) {\n    const {lineHeight, fontSize, color, textAlign} = config.text\n    const rowSpace = (lineHeight - fontSize) / 2\n    const offsetY = -3 /** 修复文字上方的默认空隙 */\n    ctx.setFontSize(fontSize)\n    ctx.setFillStyle(color)\n    ctx.setTextAlign(textAlign)\n    if (draw) {\n      ctx.fillText(text, x + rowSpace + textIndent, y + rowSpace + offsetY)\n    }\n    // 用 stroke 会导致字体模糊\n    // if(bold) {\n    //   ctx.setStrokeStyle(color)\n    //   draw ? ctx.strokeText(text, x + rowSpace + textIndent, y + rowSpace + offsetY) : doNoThing;\n    // }\n\n    // 当前行\n    const rect = {\n      x,\n      y,\n      width: ctx.measureText('' + text).width + textIndent,\n      height: lineHeight,\n    }\n\n    return calcBoundingRect(rect)\n  }\n\n  // 画下一行文字\n  const _nextLine = function(text, prevLine, draw = true) {\n    const {x, y, height} = prevLine\n    return _drawText(text, x, y + height, draw)\n  }\n\n  // 判断是否是换行符\n  const isLineBreak = function(char) {\n    const regex = /\\n|\\r/\n    return regex.test(char)\n  }\n\n  // 判断是否含有换行符\n  const containsLineBreak = function(text) {\n    const regex = /\\n|\\r/g\n    return regex.test(text)\n  }\n\n  const isOverMaxWidth = function(text, fontSize, textIndent = 0, maxWidth) {\n    ctx.setFontSize(fontSize)\n    return ctx.measureText(text + '').width + textIndent > maxWidth\n  }\n\n  const setText = function(text, x, y, options) {\n    Object.assign(config.text, DEFAULT_TEXT_CONFIG, options)\n\n    // 状态的设置要尽快执行，不然会影响到 measureText\n    const {fontSize, baseLine, draw, lineLimit, textAlign, textIndent} = config.text\n    let {maxWidth, lineHeight} = config.text\n    maxWidth = maxWidth || config.CANVAS_WIDTH\n    if (lineHeight < fontSize) {\n      lineHeight = fontSize\n      config.text.lineHeight = fontSize\n    }\n    ctx.setFontSize(fontSize)\n    ctx.setTextBaseline(baseLine)\n\n    if (isOverMaxWidth(text, fontSize, textIndent, maxWidth) || containsLineBreak(text)) {\n      // 需要分行\n      let prevLine = {}\n      let lineNumber = 0\n      for (let i = 1; i <= text.length; i++) {\n        // 到达限制行数\n        if (lineLimit > 0 && lineNumber === lineLimit) {\n          text = ''\n          break\n        }\n\n        let lineText = text.substring(0, i)\n        // 换行\n        if (\n          isOverMaxWidth(lineText, fontSize, lineNumber === 0 ? textIndent : 0, maxWidth) ||\n          isLineBreak(lineText[lineText.length - 1])\n        ) {\n          let printText\n          if (isLineBreak(lineText[lineText.length - 1])) {\n            // 换行符换行\n            printText = lineText.slice(0, lineText.length - 1)\n            text = text.slice(lineText.length, text.length)\n          } else {\n            // 普通换行\n            printText = lineText.slice(0, lineText.length - 1)\n            text = text.slice(printText.length, text.length)\n          }\n          if (lineNumber === 0) {\n            prevLine = _drawText(printText, x, y, draw, textIndent)\n          } else {\n            prevLine = _nextLine(printText, prevLine, draw)\n          }\n          i = 0\n          lineNumber++\n        }\n      }\n\n      // 区分最后一行有无文字\n      if (text) {\n        _nextLine(text, prevLine, draw)\n        lineNumber++\n      }\n\n      let rect = {\n        x,\n        y,\n        width: maxWidth,\n        height: lineNumber * lineHeight,\n      }\n      rect = _recalcAlignTextRect(rect, textAlign)\n      return calcBoundingRect(rect)\n    } else {\n      // 不需要分行\n      let rect = _drawText(text, x, y, draw, textIndent)\n      rect = _recalcAlignTextRect(rect, textAlign)\n      return calcBoundingRect(rect)\n    }\n  }\n\n  // 计算文字的包围盒\n  const calcTextBoundingRect = function(text, x, y, options) {\n    return setText(text, x, y, {...options, draw: false})\n  }\n\n  /**\n   * 图像\n   * 要实现的效果如下：\n   * 1. 能够设置图片的圆角\n   * 2. 能够描边，支持矩形/圆角形状\n   * 3. 能够设置图片的裁剪效果和缩放，和微信 image 的 mode 对应\n   */\n\n  const loadImages = function(srcs) {\n    const promises = srcs.map(item => {\n      return new Promise((resolve, reject) => {\n        wx.getImageInfo({\n          src: item,\n          success: res => resolve(res),\n          fail: err => reject(err),\n        })\n      })\n    })\n\n    return Promise.all(promises)\n  }\n\n  // 创建矩形路径\n  const createRectPath = function(x, y, width, height, radius) {\n    const leftTop = {x, y}\n    const rightTop = {x: x + width, y}\n    const rightBottom = {x: x + width, y: y + height}\n    const leftBottom = {x, y: y + height}\n    ctx.beginPath()\n    ctx.moveTo(leftTop.x, leftTop.y + radius)\n    ctx.arc(leftTop.x + radius, leftTop.y + radius, radius, degToRad(180), degToRad(270))\n    ctx.lineTo(rightTop.x - radius, rightTop.y)\n    ctx.arc(rightTop.x - radius, rightTop.y + radius, radius, degToRad(270), degToRad(360))\n    ctx.lineTo(rightBottom.x, rightBottom.y - radius)\n    ctx.arc(rightBottom.x - radius, rightBottom.y - radius, radius, degToRad(0), degToRad(90))\n    ctx.lineTo(leftBottom.x + radius, leftBottom.y)\n    ctx.arc(leftBottom.x + radius, leftBottom.y - radius, radius, degToRad(90), degToRad(180))\n    ctx.lineTo(leftTop.x, leftTop.y + radius)\n    ctx.closePath()\n  }\n\n  // 画图像\n  const drawImage = function(\n    image,\n    x,\n    y,\n    {\n      mode = 'scaleToFill',\n      width = image.width,\n      height = image.height,\n      borderRadius = 0,\n      borderWidth = 0,\n      borderColor = '#000',\n      draw = true,\n    } = {}\n  ) {\n    // 图形裁剪\n    let imgX = 0\n    let imgY = 0\n    let imgWidth = image.width\n    let imgHeight = image.height\n    const apsectWidth = width / imgWidth\n    const apsectHeight = height / imgHeight\n    const isWidthMoreLong = apsectWidth < apsectHeight\n    /** 安卓下会出现裁剪 gif 失败， 图片完全显示白色背景的现象 */\n    let needCutOut = !/\\.gif$/.test(image.path)\n    switch (mode) {\n      case 'aspectFit': {\n        if (isWidthMoreLong) {\n          height = imgHeight * apsectWidth\n        } else {\n          width = imgWidth * apsectHeight\n        }\n        break\n      }\n      case 'aspectFill': {\n        if (isWidthMoreLong) {\n          imgX = (imgWidth - width / apsectHeight) / 2\n          imgWidth = width / apsectHeight\n        } else {\n          imgY = (imgHeight - height / apsectWidth) / 2\n          imgHeight = height / apsectWidth\n        }\n        break\n      }\n      case 'widthFix': {\n        height = imgHeight * apsectWidth\n        break\n      }\n      case 'center': {\n        imgX = (imgWidth - width) / 2\n        imgY = (imgHeight - height) / 2\n        imgWidth = width\n        imgHeight = height\n        break\n      }\n      case 'top': {\n        imgX = (imgWidth - width) / 2\n        imgWidth = width\n        imgHeight = height\n        break\n      }\n      case 'bottom': {\n        imgX = (imgWidth - width) / 2\n        imgY = imgHeight - height\n        imgWidth = width\n        imgHeight = height\n        break\n      }\n      case 'left': {\n        imgY = (imgHeight - height) / 2\n        imgWidth = width\n        imgHeight = height\n        break\n      }\n      case 'right': {\n        imgX = imgWidth - width\n        imgY = (imgHeight - height) / 2\n        imgWidth = width\n        imgHeight = height\n        break\n      }\n      case 'none': {\n        needCutOut = false\n        break\n      }\n      default: {\n        break\n      }\n    }\n\n    if (draw) {\n      // 画边框\n      if (borderWidth > 0) {\n        // TODO 存在bug,不用 strokeRect(x, y, width, height, borderRadius, borderWidth, borderColor)\n        fillRect(\n          x - borderWidth,\n          y - borderWidth,\n          width + 2 * borderWidth,\n          height + 2 * borderWidth,\n          borderRadius + borderWidth,\n          borderColor\n        )\n      }\n\n      // 图形圆角效果\n      ctx.save()\n      createRectPath(x, y, width, height, borderRadius)\n      ctx.clip()\n      if (needCutOut) {\n        ctx.drawImage(image.path, imgX, imgY, imgWidth, imgHeight, x, y, width, height)\n      } else {\n        ctx.drawImage(image.path, x, y, width, height)\n      }\n      ctx.restore()\n    }\n\n    let rect = {\n      x: x - borderWidth,\n      y: y - borderWidth,\n      width: width + 2 * borderWidth,\n      height: height + 2 * borderWidth,\n    }\n    return calcBoundingRect(rect)\n  }\n\n  /**\n   * 基本图形\n   */\n\n  // 填充矩形\n  const fillRect = function(x, y, width, height, borderRadius = 0, color = '#fff') {\n    createRectPath(x, y, width, height, borderRadius)\n    if (isLinearGradientString(color)) {\n      ctx.setFillStyle(createLinearGradient(x, y, x + width, y + height, color))\n    } else if (isCircularGradientString(color)) {\n      ctx.setFillStyle(createCircularGradient(x + width / 2, y + height / 2, Math.max(width, height) / 2, color))\n    } else {\n      ctx.setFillStyle(color)\n    }\n    ctx.fill()\n    // 微信小程序bug：两个路径有重叠时，使用clip会有问题，用如下代码可以解决\n    ctx.fillRect(0, 0, 0, 0)\n    let rect = {\n      x,\n      y,\n      width,\n      height,\n    }\n    return calcBoundingRect(rect)\n  }\n\n  // 描边矩形\n  const strokeRect = function(x, y, width, height, borderRadius = 0, borderWidth = 0, borderColor = '#fff') {\n    for (let i = 1; i <= borderWidth; i++) {\n      const currBorderWidth = i\n      createRectPath(\n        x - currBorderWidth,\n        y - currBorderWidth,\n        width + 2 * currBorderWidth,\n        height + 2 * currBorderWidth,\n        borderRadius + currBorderWidth\n      )\n      ctx.setStrokeStyle(borderColor)\n      ctx.stroke()\n    }\n    // 微信小程序bug：两个路径有重叠时，使用clip会有问题，用如下代码可以解决\n    ctx.fillRect(0, 0, 0, 0)\n    let rect = {\n      x,\n      y,\n      width: width + 2 * borderWidth,\n      height: height + 2 * borderWidth,\n    }\n    return calcBoundingRect(rect)\n  }\n\n  /**\n   * 像素操作\n   */\n\n  // 拷贝像素区域\n  const copy = function(rect) {\n    return new Promise((resolve, reject) => {\n      const {x, y, width, height} = rect\n      wx.canvasGetImageData(\n        {\n          canvasId: id,\n          x,\n          y,\n          width,\n          height,\n          success: res => resolve(res),\n          fail: err => reject(err),\n        },\n        component\n      )\n    })\n  }\n\n  // 粘贴像素区域\n  const paste = function(data, rect) {\n    return new Promise((resolve, reject) => {\n      const {x, y, width, height} = rect\n      wx.canvasPutImageData(\n        {\n          canvasId: id,\n          data,\n          x,\n          y,\n          width,\n          height,\n          success: res => resolve(res),\n          fail: err => reject(err),\n        },\n        component\n      )\n    })\n  }\n\n  /**\n   * 渐变\n   */\n  const linearGradientRegex = /^(linear-gradient)\\((-?\\d+deg,(#[0-9a-fA-F]{6} \\d+%,?)+)\\);?$/g\n\n  // 判断一个字符串是否是符合规范的线性渐变字符串\n  const isLinearGradientString = function(gradientString) {\n    // linear-gradient(-180deg, #FFFFFF 0%, #D7EAFF 100%)\n    gradientString = gradientString.replace(/, /g, ',')\n    return linearGradientRegex.test(gradientString)\n  }\n\n  // 将线性渐变字符串转成对象表示\n  const parseLinearGradientString = function(gradientString) {\n    gradientString = gradientString.replace(/, /g, ',')\n    const type = gradientString.replace(linearGradientRegex, '$1')\n    const paramArray = gradientString.replace(linearGradientRegex, '$2').split(',')\n\n    // 将所有角度转成正角\n    let deg = parseFloat(paramArray[0])\n\n    let factors = [1, 1]\n    switch (deg % 360) {\n      case 0: {\n        factors = factors.concat([1, 0])\n        break\n      }\n      case 90: {\n        factors = factors.concat([0, 1])\n        break\n      }\n      case 180: {\n        factors = factors.concat([0, -1])\n        break\n      }\n      case 270: {\n        factors = factors.concat([-1, 0])\n        break\n      }\n      default: {\n        factors = factors.concat([1, 1 / Math.tan(degToRad(deg))])\n      }\n    }\n\n    let stops = []\n    for (let i = 1; i < paramArray.length; i++) {\n      const arr = paramArray[i].split(' ')\n      stops.push([parseFloat(arr[1]) / 100, arr[0]])\n    }\n\n    return {\n      type,\n      factors,\n      stops,\n    }\n  }\n\n  // 创建线性渐变\n  // 注意： 1. gradientString 的角度不支持负数\n  const createLinearGradient = function(x, y, width, height, gradientString) {\n    const gradientParams = parseLinearGradientString(gradientString)\n    console.log(x, y, x + Math.abs(width * gradientParams.factors[2]), y + Math.abs(height * gradientParams.factors[3]))\n    const grd = ctx.createLinearGradient(\n      x,\n      y,\n      x + Math.abs(width * gradientParams.factors[2]),\n      y + Math.abs(height * gradientParams.factors[3])\n    )\n    const stops = gradientParams.stops\n    console.log(stops)\n    stops.forEach(item => {\n      grd.addColorStop(item[0], item[1])\n    })\n    return grd\n  }\n\n  const circularGradientRegex = /^(circular-gradient)\\(((#[0-9a-fA-F]{6} \\d+%,?)+)\\);?$/g\n\n  // 判断一个字符串是否是符合规范的径向渐变字符串\n  const isCircularGradientString = function(gradientString) {\n    gradientString = gradientString.replace(/, /g, ',')\n    return circularGradientRegex.test(gradientString)\n  }\n\n  // 将径向渐变字符串转成对象表示\n  const parseCircularGradientString = function(gradientString) {\n    gradientString = gradientString.replace(/, /g, ',')\n    const type = gradientString.replace(circularGradientRegex, '$1')\n    const paramArray = gradientString.replace(circularGradientRegex, '$2').split(',')\n    let stops = []\n    for (let i = 0; i < paramArray.length; i++) {\n      const arr = paramArray[i].split(' ')\n      stops.push([parseFloat(arr[1]) / 100, arr[0]])\n    }\n\n    return {\n      type,\n      stops,\n    }\n  }\n\n  const createCircularGradient = function(x, y, radius, gradientString) {\n    const gradientParams = parseCircularGradientString(gradientString)\n    const stops = gradientParams.stops\n    const grd = ctx.createCircularGradient(x, y, radius)\n    stops.forEach(item => {\n      grd.addColorStop(item[0], item[1])\n    })\n    return grd\n  }\n\n  /**\n   * 渲染\n   */\n  const draw = function(reverse = true) {\n    return new Promise(resolve => {\n      ctx.draw(reverse, () => {\n        resolve()\n      })\n    })\n  }\n\n  /**\n   * 排版\n   * 要实现的规则如下：\n   * 1. 一个元素能相对于另外一个元素定位，相对于另外一个元素设置 margin\n   * 2. 一个元素自动占一行，下个元素自动起新行\n   * 3. 可以设置元素的 width 和 height\n   * 4. 支持元素的 overflow 和 text overflow\n   */\n\n  return {\n    getContext,\n    drawCoordinate,\n    calcBoundingRect,\n    setText,\n    calcTextBoundingRect,\n    loadImages,\n    drawImage,\n    fillRect,\n    strokeRect,\n    createRectPath,\n    copy,\n    paste,\n    isLinearGradientString,\n    parseLinearGradientString,\n    createLinearGradient,\n    isCircularGradientString,\n    parseCircularGradientString,\n    createCircularGradient,\n    draw,\n  }\n}\n\nmodule.exports = CanvasUtils\n"],"sourceRoot":""}